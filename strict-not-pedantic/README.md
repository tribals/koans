От больших композитных типов спасают псевдонимы. Собственно, типы, выраженные таким способом, становятся по сути "Entities" по DDD. Они начинают нести определённый смысл.

Я бы предпочёл такой подход запушить ещё дальше.

Ремарка. В чём проблема `pydantic`?

На мой взгляд, самая его основаня проблема - это способ написания "моделей". Он избрал путь писать их "на классах". Но классы - не очень подходящий язык для написания типов. Классы плохо компонуются. Отсюда большая репититивность кода (граничащая с дублированием).

Пример. Пока я писал апишку Cashoff'а, я написал их "модели" три раза - первый раз - для запросов/ответов в HTTP API, второй раз - как модели ORM (кстати, давайте модели алхимии складывать в пакет `orm`, а не `models` - тогда неймспейс `models` остаётся для, собственно моделей, например, бизнес логики :grimacing: , "Entities" опять же, по DDD), и третий раз - для запросов/ответов уже самого сервиса.

Для сервиса целиком модели HTTP API не подходили, так как плохо это - выставлять детали наружу. Внутри сервиса у нас должны быть свои модели. Но вот прям писать их все заново тоже не хотелось - некоторые вложенные миним-модельки HTTP API можно (и нужно) переиспользовать.

Pydantic - это всего-лишь набор "валидаторов" для распространённых типов данных, таких как даты, UUID, и даже email адреса. Он лимитирован применением только для аннотаций, а не непосредственно самих типов (в коде). Зачем ходить в Гондурас через Зимбабве? Давайте писать сразу полноценные типы. Как раз-таки их уже можно будет шарить, даже между сервисами, как библиотеки.

Если не pydantic, то что?

Конец ремарки.

Вот есть либа https://phantom-types.readthedocs.io/en/stable/pages/getting-started.html. Она предлагает другой подход к той же проблеме. Вместо набора валидаторов, она предоставляет набор "кусочков лего" для написания своих валидаторов. Но что более важно, типы, написанные на этой либе работают в обоих контекстах - и при статической проверке, и в рантайме. В райнтайме же они работает тупо как парсеры - подал ввод - гарантированно получил валидный вывод, либо ошибку.

Это даёт возможность не только переиспользовать такие типы в разных контекстах - при парсинге запросов/ответов, (де-)сериализации в БД, но и просто для проверки той самой "бизнес-логики". Как так? Очень просто. Тип в `phantom-types` - это набор предикатов, функций возвращающих `True/False`.

Вот в pydantic есть `HttpStr` - давайте напишем такой же тип на `phantom-types`.

```console
$ do/test phantom_url.py
$ do/check phantom_url.py
$ do/py -i phantom_url.py
```

И это только ягодки, там целая мини-библиотечка __компонуемых__ предикатово, из которых можно склепать тип прям вот предметной области на коленке.

Пы. Сы. Единственное, где такой тип не удасться использовать - это в описании ORM-модели. Но даже там они могу пригодиться как валидаторы/парсеры - в этом, собсно, и [суть](https://stianlagstad.no/2022/05/parse-dont-validate-python-edition/).
